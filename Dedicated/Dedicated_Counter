`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company          : Semicon_Academi
// Engineer         : Jiyun_Han
// 
// Create Date	    : 2025/09/17
// Design Name      : CPU_Dedicated
// Module Name      : Dedicated_Processor
// Target Devices   : Basys3
// Tool Versions    : 2020.2
// Description      : CPU Dedicated_Processor Counter
//
// Revision 	    : 
//////////////////////////////////////////////////////////////////////////////////

module Dedicated_Processor (
    // Clock & Reset
    input   logic           iClk,
    input   logic           iRst,

    output  logic   [7:0]   oOut
    );


    /***********************************************
    // Reg & Wire - Logic
    ***********************************************/
    logic           wAsrcSel;
    logic           wALoad;
    logic           wOutBufSel;
    logic           wAlt10;


    /***********************************************
    // Instantiation
    ***********************************************/	
    Ctrl    U_Ctrl  (
        .iClk       (iClk),
        .iRst       (iRst),
        .iAlt10     (wAlt10),
        .oAsrcSel   (wAsrcSel),
        .oALoad     (wALoad),
        .oOufBufSel (wOutBufSel)
    );

    DataPath    U_DP    (
        .iClk       (iClk),
        .iRst       (iRst),
        .iAsrcSel   (wAsrcSel),
        .iALoad     (wALoad),
        .iOufBufSel (wOutBufSel),
        .oAlt10     (wAlt10),
        .oOut       (oOut)
    );


endmodule


/***********************************************
// Sub Modules 1
***********************************************/
module Ctrl (
    input   logic           iClk,
    input   logic           iRst,

    input   logic           iAlt10,

    output  logic           oAsrcSel,
    output  logic           oALoad,
    output  logic           oOufBufSel
);

    typedef enum bit [2:0] {
        S0,
        S1,
        S2,
        S3,
        S4
    } state_e;

    state_e state, next;


    /***********************************************
    // FSM 
    ***********************************************/
    // Current State Update
    always_ff @(posedge iClk, posedge iRst)
    begin
        if (iRst)
        begin
            state       <= S0;
        end else
        begin
            state       <= next;
        end
    end

    // Next State Decision
    always_comb
    begin
        next            = state;

        case (state)
            S0      :
                next    = S1;

            S1      :
            begin
                if (iAlt10)
                    next    = S2;
                else
                    next    = S4;
            end

            S2      :
                next    = S3;


            S3      :
                next    = S1;


            S4      :
                next    = S4;

            default :
                next    = state;
        endcase
    end

    // Output Decision
    assign  oAsrcSel    = (state == S3)                 ? 1 : 0;
    assign  oALoad      = (state == S0 || state == S3)  ? 1 : 0;
    assign  oOufBufSel  = (state == S2)                 ? 1 : 0;

endmodule

module DataPath (
    input   logic           iClk,
    input   logic           iRst,

    input   logic           iAsrcSel,
    input   logic           iALoad,
    input   logic           iOufBufSel,

    output  logic           oAlt10,
    output  logic   [7:0]   oOut
);


    // Reg & Wire
    logic   [7:0]   wMux2Areg;
    logic   [7:0]   wAregOut;
    logic   [7:0]   wAdd2Mux;
    logic           wComp2Out;

    // Instance
    Mux_2x1 U_Mux_2x1   (
        .iAsrcSel   (iAsrcSel),
        .iA         (8'b0),
        .iB         (wAdd2Mux),
        .oMux2Areg  (wMux2Areg)
    );

    Areg    U_Areg  (
        .iClk   (iClk),
        .iRst   (iRst),
        .iALoad (iALoad),
        .iD     (wMux2Areg),
        .oQ     (wAregOut)
    );

    Comparator  U_Comp  (
        .iA     (wAregOut),
        .iB     (8'd10),
        .oAlt10 (oAlt10)
    );

    Adder   U_Add   (
        .iA     (wAregOut),
        .iB     (8'h1),
        .oSum   (wAdd2Mux)
    );

    OutBuf  U_Out   (
        .iAreg_Data (wAregOut),
        .iOufBufSel (iOufBufSel),
        .oOut       (oOut)
    );

endmodule


/***********************************************
// Sub Modules 2
***********************************************/
module Mux_2x1 (
    input   logic           iAsrcSel,
    input   logic   [7:0]   iA,
    input   logic   [7:0]   iB,
    
    output  logic   [7:0]   oMux2Areg
);

    always_comb
    begin
        oMux2Areg   = 8'b0;
        case (iAsrcSel)
            1'b0    : oMux2Areg = iA;
            1'b1    : oMux2Areg = iB;
        endcase       
    end

endmodule

module Areg (
    input   logic           iClk,
    input   logic           iRst,

    input   logic           iALoad,
    input   logic   [7:0]   iD,

    output  logic   [7:0]   oQ
);

    always_ff @(posedge iClk, posedge iRst )
    begin
        if (iRst)
            oQ  <= 0;
        else
        begin
            if (iALoad)
                oQ  <= iD;
            else
                oQ  <= oQ;
        end
    end

endmodule

module Comparator (
    input   logic   [7:0]   iA,
    input   logic   [7:0]   iB,

    output  logic           oAlt10
);

    assign  oAlt10  = iA < iB;

endmodule

module  Adder (
    input   logic   [7:0]   iA,
    input   logic   [7:0]   iB,

    output  logic   [8:0]   oSum
);

    assign  oSum    = iA + iB;

endmodule

module OutBuf (
    input   logic   [7:0]   iAreg_Data,
    input   logic           iOufBufSel,

    output  logic   [7:0]   oOut
);

    assign  oOut    = iOufBufSel ? iAreg_Data : 8'bz;

endmodule
